import { BaseCheckpointSaver, ChannelVersions, Checkpoint, CheckpointListOptions, CheckpointMetadata, CheckpointTuple, PendingWrite } from "@langchain/langgraph-checkpoint";
import { RunnableConfig } from "@langchain/core/runnables";
import { createClient, createCluster } from "redis";
export type RedisClientType = ReturnType<typeof createClient> | ReturnType<typeof createCluster>;
export interface TTLConfig {
    defaultTTL?: number;
    refreshOnRead?: boolean;
}
export declare class RedisSaver extends BaseCheckpointSaver {
    private client;
    private ttlConfig?;
    constructor(client: RedisClientType, ttlConfig?: TTLConfig);
    static fromUrl(url: string, ttlConfig?: TTLConfig): Promise<RedisSaver>;
    static fromCluster(rootNodes: Array<{
        url: string;
    }>, ttlConfig?: TTLConfig): Promise<RedisSaver>;
    get(config: RunnableConfig): Promise<Checkpoint | undefined>;
    getTuple(config: RunnableConfig): Promise<CheckpointTuple | undefined>;
    put(config: RunnableConfig, checkpoint: Checkpoint, metadata: CheckpointMetadata, newVersions: ChannelVersions): Promise<RunnableConfig>;
    list(config: RunnableConfig | null, options?: CheckpointListOptions & {
        filter?: CheckpointMetadata;
    }): AsyncGenerator<CheckpointTuple>;
    putWrites(config: RunnableConfig, writes: PendingWrite[], taskId: string): Promise<void>;
    deleteThread(threadId: string): Promise<void>;
    end(): Promise<void>;
    private loadPendingWrites;
    private loadCheckpointWithWrites;
    private migratePendingSends;
    private createCheckpointTuple;
    private addSearchableMetadataFields;
    private applyTTL;
    private ensureIndexes;
}
//# sourceMappingURL=index.d.ts.map