import { createClient, createCluster } from "redis";
/** A conventional Redis connection. */
export type RedisClientConnection = ReturnType<typeof createClient>;
/** A clustered Redis connection. */
export type RedisClusterConnection = ReturnType<typeof createCluster>;
/** A Redis connection, clustered or conventional. */
export type RedisConnection = RedisClientConnection | RedisClusterConnection;
import { type GetOperation, type ListNamespacesOperation, type Operation, type PutOperation, type SearchOperation } from "@langchain/langgraph-checkpoint";
export declare function isPutOperation(op: Operation): op is PutOperation;
export declare function isGetOperation(op: Operation): op is GetOperation;
export declare function isSearchOperation(op: Operation): op is SearchOperation;
export declare function isListNamespacesOperation(op: Operation): op is ListNamespacesOperation;
export interface FilterOperators {
    $eq?: any;
    $ne?: any;
    $gt?: number;
    $gte?: number;
    $lt?: number;
    $lte?: number;
    $in?: any[];
    $nin?: any[];
    $exists?: boolean;
}
export type FilterValue = any | FilterOperators;
export type Filter = Record<string, FilterValue>;
/**
 * Internal class for evaluating filters against documents.
 * Supports MongoDB-style query operators.
 */
declare class FilterBuilder {
    /**
     * Evaluates if a document matches the given filter criteria.
     * Supports advanced operators like $gt, $lt, $in, etc.
     */
    static matchesFilter(doc: Record<string, any>, filter: Filter): boolean;
    /**
     * Builds a Redis Search query string from filter criteria.
     * Note: This is limited by RediSearch capabilities and may not support all operators.
     */
    static buildRedisSearchQuery(filter: Filter, prefix?: string): {
        query: string;
        useClientFilter: boolean;
    };
    private static matchesFieldFilter;
    private static matchesOperators;
    private static matchesOperator;
    private static isEqual;
    private static getNestedValue;
}
export interface Item {
    value: any;
    key: string;
    namespace: string[];
    created_at: Date;
    updated_at: Date;
}
export interface SearchItem extends Item {
    score?: number;
}
export interface IndexConfig {
    dims: number;
    embed?: any;
    distanceType?: "cosine" | "l2" | "ip";
    fields?: string[];
    vectorStorageType?: string;
    similarityThreshold?: number;
}
export interface TTLConfig {
    defaultTTL?: number;
    refreshOnRead?: boolean;
}
export interface StoreConfig {
    index?: IndexConfig;
    ttl?: TTLConfig;
}
export declare class RedisStore {
    private readonly client;
    private readonly indexConfig?;
    private readonly ttlConfig?;
    private readonly embeddings?;
    constructor(client: RedisConnection, config?: StoreConfig);
    static fromConnString(connString: string, config?: StoreConfig): Promise<RedisStore>;
    static fromCluster(rootNodes: Array<{
        url: string;
    }>, config?: StoreConfig): Promise<RedisStore>;
    setup(): Promise<void>;
    get(namespace: string[], key: string, options?: {
        refreshTTL?: boolean;
    }): Promise<Item | null>;
    put(namespace: string[], key: string, value: any, options?: {
        ttl?: number;
        index?: boolean | string[];
    }): Promise<void>;
    delete(namespace: string[], key: string): Promise<void>;
    search(namespacePrefix: string[], options?: {
        filter?: Filter;
        query?: string;
        limit?: number;
        offset?: number;
        refreshTTL?: boolean;
        similarityThreshold?: number;
    }): Promise<SearchItem[]>;
    listNamespaces(options?: {
        prefix?: string[];
        suffix?: string[];
        maxDepth?: number;
        limit?: number;
        offset?: number;
    }): Promise<string[][]>;
    batch(ops: Operation[]): Promise<any[]>;
    close(): Promise<void>;
    /**
     * Get statistics about the store.
     * Returns document counts and other metrics.
     */
    getStatistics(): Promise<{
        totalDocuments: number;
        namespaceCount: number;
        vectorDocuments?: number;
        indexInfo?: Record<string, any>;
    }>;
    private validateNamespace;
    private refreshItemTTL;
    private escapeTagValue;
    /**
     * Calculate similarity score based on the distance metric.
     * Converts raw distance to a normalized similarity score [0,1].
     */
    private calculateSimilarityScore;
}
export { FilterBuilder };
//# sourceMappingURL=store.d.ts.map