import { BaseCheckpointSaver, ChannelVersions, Checkpoint, CheckpointListOptions, CheckpointMetadata, CheckpointTuple, PendingWrite } from "@langchain/langgraph-checkpoint";
import { RunnableConfig } from "@langchain/core/runnables";
export interface TTLConfig {
    defaultTTL?: number;
    refreshOnRead?: boolean;
}
/**
 * ShallowRedisSaver - A Redis checkpoint saver that only keeps the latest checkpoint per thread.
 *
 * This is a memory-optimized variant that:
 * - Only stores the most recent checkpoint for each thread
 * - Stores channel values inline (no separate blob storage)
 * - Automatically cleans up old checkpoints and writes when new ones are added
 * - Reduces storage usage for applications that don't need checkpoint history
 */
export declare class ShallowRedisSaver extends BaseCheckpointSaver {
    private client;
    private ttlConfig?;
    constructor(client: any, ttlConfig?: TTLConfig);
    static fromUrl(url: string, ttlConfig?: TTLConfig): Promise<ShallowRedisSaver>;
    get(config: RunnableConfig): Promise<Checkpoint | undefined>;
    put(config: RunnableConfig, checkpoint: Checkpoint, metadata: CheckpointMetadata, _newVersions: ChannelVersions): Promise<RunnableConfig>;
    getTuple(config: RunnableConfig): Promise<CheckpointTuple | undefined>;
    list(config: RunnableConfig | null, options?: CheckpointListOptions & {
        filter?: CheckpointMetadata;
    }): AsyncGenerator<CheckpointTuple>;
    putWrites(config: RunnableConfig, writes: PendingWrite[], taskId: string): Promise<void>;
    deleteThread(threadId: string): Promise<void>;
    end(): Promise<void>;
    private addSearchableMetadataFields;
    private createCheckpointTuple;
    private applyTTL;
    private loadPendingWrites;
    private checkMetadataFilterMatch;
    private cleanupOldCheckpoint;
    private sanitizeMetadata;
    private ensureIndexes;
}
//# sourceMappingURL=shallow.d.ts.map